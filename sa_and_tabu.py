# -*- coding: utf-8 -*-
"""SA and TABU

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/163f38J9wJqIKTq46hTliHDkMs5d56jLg
"""

from dataclasses import dataclass
from typing import List, Optional
import random
import math
import time


# =========================
# 0) Dataclasses & Simulator
# =========================

@dataclass
class InstanceParams:
    n_products: int          # |N|
    n_fdcs: int              # |J|
    T: int                   # number of periods

    # D_fdc[t][i][j], D_rdc[t][i], R[t][i]
    D_fdc: List[List[List[float]]]   # demand at FDCs
    D_rdc: List[List[float]]         # demand at RDC (can be all zeros)
    R: List[List[float]]             # replenishments into RDC

    I0_rdc: List[float]              # initial RDC inventory for each product i
    I0_fdc: List[List[float]]        # initial FDC inventory: I0_fdc[i][j]

    Q: List[float]                   # RDC outbound capacity per period
    C_fdc: Optional[List[Optional[float]]]  # FDC capacity per j (None = no limit)

    # costs
    r: List[List[float]]             # transfer costs r[i][j]
    c: float                         # penalty for RDC serving FDC demand
    s: float                         # penalty for lost sales


@dataclass
class SimulationResult:
    total_cost: float
    cost_transfer: float
    cost_cross: float
    cost_lost: float

    I_rdc: List[List[float]]
    I_fdc: List[List[List[float]]]

    ship: List[List[List[float]]]
    x_fdc: List[List[List[float]]]
    y_fdc: List[List[List[float]]]
    z_fdc: List[List[List[float]]]

    y_rdc: List[List[float]]
    z_rdc: List[List[float]]

    clipped_shipments: float


def simulate_plan(params: InstanceParams,
                  U: List[List[List[float]]],
                  repair_infeas: bool = True) -> SimulationResult:
    """
    Simulate one shipment plan U (u_ij^t) over the whole horizon.
    The simulator clips shipments to respect RDC inventory, FDC capacity,
    and outbound capacity Q[t].
    """
    n_products = params.n_products
    n_fdcs = params.n_fdcs
    T = params.T

    D_fdc = params.D_fdc
    D_rdc = params.D_rdc
    R = params.R
    I0_rdc = params.I0_rdc
    I0_fdc = params.I0_fdc
    Q = params.Q
    C_fdc = params.C_fdc
    r = params.r
    c = params.c
    s = params.s

    # Inventories over time
    I_rdc = [[0.0 for _ in range(n_products)] for _ in range(T + 1)]
    I_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T + 1)]

    # Initial inventories
    for i in range(n_products):
        I_rdc[0][i] = I0_rdc[i]
        for j in range(n_fdcs):
            I_fdc[0][i][j] = I0_fdc[i][j]

    # Flows and results
    ship = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    x_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    y_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    z_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    y_rdc = [[0.0 for _ in range(n_products)] for _ in range(T)]
    z_rdc = [[0.0 for _ in range(n_products)] for _ in range(T)]

    total_transfer_cost = 0.0
    total_cross_cost = 0.0
    total_lost_cost = 0.0
    clipped_shipments = 0.0

    for t in range(T):
        # 1) Replenishment at RDC
        for i in range(n_products):
            I_rdc[t][i] += R[t][i]

        remaining_Q = Q[t]

        # FDC total inventory for capacity
        current_fdc_total = [0.0 for _ in range(n_fdcs)]
        for j in range(n_fdcs):
            total_j = 0.0
            for i in range(n_products):
                total_j += I_fdc[t][i][j]
            current_fdc_total[j] = total_j

        # 2) Shipments from RDC to FDCs (respect Q, FDC capacity, RDC inventory)
        for i in range(n_products):
            for j in range(n_fdcs):
                request = U[t][i][j]
                if request <= 0:
                    continue

                avail_rdc = I_rdc[t][i]
                if C_fdc is not None and C_fdc[j] is not None:
                    cap_left = C_fdc[j] - current_fdc_total[j]
                else:
                    cap_left = float('inf')

                cap_Q = remaining_Q
                feasible_ship = min(request, avail_rdc, cap_left, cap_Q)
                if feasible_ship < request:
                    clipped_shipments += (request - feasible_ship)

                ship[t][i][j] = feasible_ship
                I_rdc[t][i] -= feasible_ship
                current_fdc_total[j] += feasible_ship
                remaining_Q -= feasible_ship

        # 3) FDC local fulfillment
        for i in range(n_products):
            for j in range(n_fdcs):
                avail_fdc = I_fdc[t][i][j] + ship[t][i][j]
                demand_fdc = D_fdc[t][i][j]

                use_local = min(avail_fdc, demand_fdc)
                x_fdc[t][i][j] = use_local

                avail_fdc -= use_local
                remaining_demand = demand_fdc - use_local

                # leftover inventory moves to next period
                I_fdc[t+1][i][j] = avail_fdc

                # 4) Cross-fulfillment from RDC
                if remaining_demand > 0:
                    avail_rdc = I_rdc[t][i]
                    cross = min(remaining_demand, avail_rdc)
                    y_fdc[t][i][j] = cross
                    I_rdc[t][i] -= cross
                    remaining_demand -= cross

                    # 5) Lost sales at FDC
                    z_fdc[t][i][j] = remaining_demand
                else:
                    y_fdc[t][i][j] = 0.0
                    z_fdc[t][i][j] = 0.0

        # 6) RDC own demand
        for i in range(n_products):
            demand_rdc = D_rdc[t][i]
            if demand_rdc <= 0:
                I_rdc[t+1][i] = I_rdc[t][i]
                continue

            avail_rdc = I_rdc[t][i]
            fulfil = min(avail_rdc, demand_rdc)
            y_rdc[t][i] = fulfil
            I_rdc[t][i] -= fulfil
            lost = demand_rdc - fulfil
            z_rdc[t][i] = lost
            I_rdc[t+1][i] = I_rdc[t][i]

        # 7) Costs for period t
        for i in range(n_products):
            for j in range(n_fdcs):
                total_transfer_cost += r[i][j] * ship[t][i][j]
        for i in range(n_products):
            for j in range(n_fdcs):
                total_cross_cost += c * y_fdc[t][i][j]
        for i in range(n_products):
            for j in range(n_fdcs):
                total_lost_cost += s * z_fdc[t][i][j]
            total_lost_cost += s * z_rdc[t][i]

    total_cost = total_transfer_cost + total_cross_cost + total_lost_cost

    return SimulationResult(
        total_cost=total_cost,
        cost_transfer=total_transfer_cost,
        cost_cross=total_cross_cost,
        cost_lost=total_lost_cost,
        I_rdc=I_rdc,
        I_fdc=I_fdc,
        ship=ship,
        x_fdc=x_fdc,
        y_fdc=y_fdc,
        z_fdc=z_fdc,
        y_rdc=y_rdc,
        z_rdc=z_rdc,
        clipped_shipments=clipped_shipments
    )


# ==============================
# 1) Synthetic Instance Generator
# ==============================

def build_synthetic_instance(
    n_products: int = 200,
    n_fdcs: int = 50,
    T: int = 10,
    demand_low: int = 5,
    demand_high: int = 30,
    seed: int = 42
) -> (InstanceParams, List[List[List[float]]]):
    """
    Build a synthetic multi-product, multi-FDC, single-RDC instance.
    Increase n_products / n_fdcs if your machine can handle it (e.g. up to ~1000 products).
    """
    random.seed(seed)

    # Initialize structures
    D_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    D_rdc = [[0.0 for _ in range(n_products)] for _ in range(T)]
    R = [[0.0 for _ in range(n_products)] for _ in range(T)]
    I0_rdc = [0.0 for _ in range(n_products)]
    I0_fdc = [[0.0 for _ in range(n_fdcs)] for _ in range(n_products)]

    # 1) Generate FDC demands and track totals
    total_demand_per_product = [0.0 for _ in range(n_products)]
    total_demand_per_period = [0.0 for _ in range(T)]

    for t in range(T):
        for i in range(n_products):
            for j in range(n_fdcs):
                base = random.randint(demand_low, demand_high)
                # small temporal fluctuation
                fluct = 1.0 + 0.2 * math.sin(2 * math.pi * (t + 1) / T)
                val = max(0, int(base * fluct))
                D_fdc[t][i][j] = float(val)
                total_demand_per_product[i] += val
                total_demand_per_period[t] += val

    # 2) Initial RDC inventory ~70% of horizon demand per product
    for i in range(n_products):
        I0_rdc[i] = 0.7 * total_demand_per_product[i]

    # 3) No replenishment during horizon (all stock upfront) -> R already zero

    # 4) Outbound capacity Q[t] ~60% of total demand that period
    Q = [0.6 * total_demand_per_period[t] for t in range(T)]

    # 5) FDC capacities ~80% of their total horizon demand
    C_fdc = [0.0 for _ in range(n_fdcs)]
    for j in range(n_fdcs):
        s = 0.0
        for t in range(T):
            for i in range(n_products):
                s += D_fdc[t][i][j]
        C_fdc[j] = 0.8 * s

    # 6) Costs
    r_cost = [[1.0 for _ in range(n_fdcs)] for _ in range(n_products)]  # unit transfer cost
    c = 3.0       # RDC cross-fulfillment penalty
    s_cost = 10.0 # lost sales penalty

    params = InstanceParams(
        n_products=n_products,
        n_fdcs=n_fdcs,
        T=T,
        D_fdc=D_fdc,
        D_rdc=D_rdc,
        R=R,
        I0_rdc=I0_rdc,
        I0_fdc=I0_fdc,
        Q=Q,
        C_fdc=C_fdc,
        r=r_cost,
        c=c,
        s=s_cost
    )

    # Initial shipment plan: all zeros
    U0 = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]

    return params, U0


# ==========================
# 2) Helpers & Neighborhoods
# ==========================

def copy_plan(U: List[List[List[float]]]) -> List[List[List[float]]]:
    """Deep copy of 3D plan list."""
    return [[row[:] for row in period] for period in U]


def random_neighbor(U: List[List[List[float]]],
                    params: InstanceParams,
                    delta_choices=(5.0, 10.0, 20.0)) -> List[List[List[float]]]:
    """
    Neighborhood move: pick random (t,i,j) and tweak u_{ij}^t by +/- delta.
    Feasibility is enforced later by the simulator via clipping.
    """
    T = params.T
    n_products = params.n_products
    n_fdcs = params.n_fdcs

    newU = copy_plan(U)
    t = random.randrange(T)
    i = random.randrange(n_products)
    j = random.randrange(n_fdcs)
    delta = random.choice(delta_choices)

    if random.random() < 0.5:
        newU[t][i][j] += delta
    else:
        newU[t][i][j] = max(0.0, newU[t][i][j] - delta)

    return newU


# =====================
# 3) Simulated Annealing
# =====================

def simulated_annealing(params: InstanceParams,
                        U_init: List[List[List[float]]],
                        T0: float,
                        alpha: float,
                        n_iters: int) -> (float, List[List[List[float]]]):
    """
    Basic SA over shipment plans U.
    Returns (best_cost, best_U).
    """
    current_U = copy_plan(U_init)
    current_cost = simulate_plan(params, current_U).total_cost
    best_U = copy_plan(current_U)
    best_cost = current_cost

    T = T0
    for k in range(n_iters):
        candidate_U = random_neighbor(current_U, params)
        candidate_cost = simulate_plan(params, candidate_U).total_cost
        delta = candidate_cost - current_cost

        if delta <= 0 or random.random() < math.exp(-delta / max(T, 1e-9)):
            current_U = candidate_U
            current_cost = candidate_cost
            if current_cost < best_cost:
                best_cost = current_cost
                best_U = copy_plan(current_U)

        T *= alpha
        if T < 1e-6:
            break

    return best_cost, best_U


# =====================
# 4) SA Tuning Loop
# =====================

def tune_sa():
    # You can scale these up if your machine is strong
    params, U0 = build_synthetic_instance(
        n_products=200,   # try 500 or 1000 later if it's not too slow
        n_fdcs=50,
        T=10,
        seed=123
    )

    print(f"Instance: {params.n_products} products, "
          f"{params.n_fdcs} FDCs, {params.T} periods")

    # ---- SA parameter grid ----
    # More values for T0 and alpha to be more precise
    T0_values = [2e4, 5e4, 1e5, 2e5]
    alpha_values = [0.90, 0.93, 0.96, 0.98]

    sa_configs = []
    for T0 in T0_values:
        for alpha in alpha_values:
            sa_configs.append({"T0": T0, "alpha": alpha})

    n_sa_runs = 5   # number of runs per config (increase for more precision)
    sa_iters = 300  # iterations per SA run (increase for more search)

    best_sa_cfg = None
    best_sa_avg = float("inf")

    print("\n=== Simulated Annealing tuning ===")
    for cfg in sa_configs:
        costs = []
        start_time = time.time()
        for run in range(n_sa_runs):
            random.seed(1000 + run)  # reproducible
            best_cost, _ = simulated_annealing(
                params, U0,
                T0=cfg["T0"],
                alpha=cfg["alpha"],
                n_iters=sa_iters
            )
            costs.append(best_cost)
        elapsed = time.time() - start_time
        avg_cost = sum(costs) / len(costs)
        print(f"SA cfg {cfg} -> avg best cost over {n_sa_runs} runs: {avg_cost:.2f} "
              f"(time {elapsed:.1f}s)")
        if avg_cost < best_sa_avg:
            best_sa_avg = avg_cost
            best_sa_cfg = cfg

    print(f"\nBest SA config: {best_sa_cfg} with avg best cost {best_sa_avg:.2f}")


if __name__ == "__main__":
    tune_sa()

from dataclasses import dataclass
from typing import List, Optional
import random
import math
import time


# =========================
# 0) Dataclasses & Simulator
# =========================

@dataclass
class InstanceParams:
    n_products: int          # |N|
    n_fdcs: int              # |J|
    T: int                   # number of periods

    # D_fdc[t][i][j], D_rdc[t][i], R[t][i]
    D_fdc: List[List[List[float]]]   # demand at FDCs
    D_rdc: List[List[float]]         # demand at RDC (can be all zeros)
    R: List[List[float]]             # replenishments into RDC

    I0_rdc: List[float]              # initial RDC inventory for each product i
    I0_fdc: List[List[float]]        # initial FDC inventory: I0_fdc[i][j]

    Q: List[float]                   # RDC outbound capacity per period
    C_fdc: Optional[List[Optional[float]]]  # FDC capacity per j (None = no limit)

    # costs
    r: List[List[float]]             # transfer costs r[i][j]
    c: float                         # penalty for RDC serving FDC demand
    s: float                         # penalty for lost sales


@dataclass
class SimulationResult:
    total_cost: float
    cost_transfer: float
    cost_cross: float
    cost_lost: float

    I_rdc: List[List[float]]
    I_fdc: List[List[List[float]]]

    ship: List[List[List[float]]]
    x_fdc: List[List[List[float]]]
    y_fdc: List[List[List[float]]]
    z_fdc: List[List[List[float]]]

    y_rdc: List[List[float]]
    z_rdc: List[List[float]]

    clipped_shipments: float


def simulate_plan(params: InstanceParams,
                  U: List[List[List[float]]],
                  repair_infeas: bool = True) -> SimulationResult:
    n_products = params.n_products
    n_fdcs = params.n_fdcs
    T = params.T

    D_fdc = params.D_fdc
    D_rdc = params.D_rdc
    R = params.R
    I0_rdc = params.I0_rdc
    I0_fdc = params.I0_fdc
    Q = params.Q
    C_fdc = params.C_fdc
    r = params.r
    c = params.c
    s = params.s

    I_rdc = [[0.0 for _ in range(n_products)] for _ in range(T + 1)]
    I_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T + 1)]

    for i in range(n_products):
        I_rdc[0][i] = I0_rdc[i]
        for j in range(n_fdcs):
            I_fdc[0][i][j] = I0_fdc[i][j]

    ship = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    x_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    y_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    z_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    y_rdc = [[0.0 for _ in range(n_products)] for _ in range(T)]
    z_rdc = [[0.0 for _ in range(n_products)] for _ in range(T)]

    total_transfer_cost = 0.0
    total_cross_cost = 0.0
    total_lost_cost = 0.0
    clipped_shipments = 0.0

    for t in range(T):
        for i in range(n_products):
            I_rdc[t][i] += R[t][i]

        remaining_Q = Q[t]

        current_fdc_total = [0.0 for _ in range(n_fdcs)]
        for j in range(n_fdcs):
            total_j = 0.0
            for i in range(n_products):
                total_j += I_fdc[t][i][j]
            current_fdc_total[j] = total_j

        for i in range(n_products):
            for j in range(n_fdcs):
                request = U[t][i][j]
                if request <= 0:
                    continue

                avail_rdc = I_rdc[t][i]
                if C_fdc is not None and C_fdc[j] is not None:
                    cap_left = C_fdc[j] - current_fdc_total[j]
                else:
                    cap_left = float('inf')

                cap_Q = remaining_Q
                feasible_ship = min(request, avail_rdc, cap_left, cap_Q)
                if feasible_ship < request:
                    clipped_shipments += (request - feasible_ship)

                ship[t][i][j] = feasible_ship
                I_rdc[t][i] -= feasible_ship
                current_fdc_total[j] += feasible_ship
                remaining_Q -= feasible_ship

        for i in range(n_products):
            for j in range(n_fdcs):
                avail_fdc = I_fdc[t][i][j] + ship[t][i][j]
                demand_fdc = D_fdc[t][i][j]

                use_local = min(avail_fdc, demand_fdc)
                x_fdc[t][i][j] = use_local

                avail_fdc -= use_local
                remaining_demand = demand_fdc - use_local

                I_fdc[t+1][i][j] = avail_fdc

                if remaining_demand > 0:
                    avail_rdc = I_rdc[t][i]
                    cross = min(remaining_demand, avail_rdc)
                    y_fdc[t][i][j] = cross
                    I_rdc[t][i] -= cross
                    remaining_demand -= cross
                    z_fdc[t][i][j] = remaining_demand
                else:
                    y_fdc[t][i][j] = 0.0
                    z_fdc[t][i][j] = 0.0

        for i in range(n_products):
            demand_rdc = D_rdc[t][i]
            if demand_rdc <= 0:
                I_rdc[t+1][i] = I_rdc[t][i]
                continue

            avail_rdc = I_rdc[t][i]
            fulfil = min(avail_rdc, demand_rdc)
            y_rdc[t][i] = fulfil
            I_rdc[t][i] -= fulfil
            lost = demand_rdc - fulfil
            z_rdc[t][i] = lost
            I_rdc[t+1][i] = I_rdc[t][i]

        for i in range(n_products):
            for j in range(n_fdcs):
                total_transfer_cost += r[i][j] * ship[t][i][j]
        for i in range(n_products):
            for j in range(n_fdcs):
                total_cross_cost += c * y_fdc[t][i][j]
        for i in range(n_products):
            for j in range(n_fdcs):
                total_lost_cost += s * z_fdc[t][i][j]
            total_lost_cost += s * z_rdc[t][i]

    total_cost = total_transfer_cost + total_cross_cost + total_lost_cost

    return SimulationResult(
        total_cost=total_cost,
        cost_transfer=total_transfer_cost,
        cost_cross=total_cross_cost,
        cost_lost=total_lost_cost,
        I_rdc=I_rdc,
        I_fdc=I_fdc,
        ship=ship,
        x_fdc=x_fdc,
        y_fdc=y_fdc,
        z_fdc=z_fdc,
        y_rdc=y_rdc,
        z_rdc=z_rdc,
        clipped_shipments=clipped_shipments
    )


# ==============================
# 1) Synthetic Instance Generator
# ==============================

def build_synthetic_instance(
    n_products: int = 200,
    n_fdcs: int = 50,
    T: int = 10,
    demand_low: int = 5,
    demand_high: int = 30,
    seed: int = 42
) -> (InstanceParams, List[List[List[float]]]):
    random.seed(seed)

    D_fdc = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]
    D_rdc = [[0.0 for _ in range(n_products)] for _ in range(T)]
    R = [[0.0 for _ in range(n_products)] for _ in range(T)]
    I0_rdc = [0.0 for _ in range(n_products)]
    I0_fdc = [[0.0 for _ in range(n_fdcs)] for _ in range(n_products)]

    total_demand_per_product = [0.0 for _ in range(n_products)]
    total_demand_per_period = [0.0 for _ in range(T)]

    for t in range(T):
        for i in range(n_products):
            for j in range(n_fdcs):
                base = random.randint(demand_low, demand_high)
                fluct = 1.0 + 0.2 * math.sin(2 * math.pi * (t + 1) / T)
                val = max(0, int(base * fluct))
                D_fdc[t][i][j] = float(val)
                total_demand_per_product[i] += val
                total_demand_per_period[t] += val

    for i in range(n_products):
        I0_rdc[i] = 0.7 * total_demand_per_product[i]

    Q = [0.6 * total_demand_per_period[t] for t in range(T)]

    C_fdc = [0.0 for _ in range(n_fdcs)]
    for j in range(n_fdcs):
        s = 0.0
        for t in range(T):
            for i in range(n_products):
                s += D_fdc[t][i][j]
        C_fdc[j] = 0.8 * s

    r_cost = [[1.0 for _ in range(n_fdcs)] for _ in range(n_products)]
    c = 3.0
    s_cost = 10.0

    params = InstanceParams(
        n_products=n_products,
        n_fdcs=n_fdcs,
        T=T,
        D_fdc=D_fdc,
        D_rdc=D_rdc,
        R=R,
        I0_rdc=I0_rdc,
        I0_fdc=I0_fdc,
        Q=Q,
        C_fdc=C_fdc,
        r=r_cost,
        c=c,
        s=s_cost
    )

    U0 = [[[0.0 for _ in range(n_fdcs)] for _ in range(n_products)] for _ in range(T)]

    return params, U0


# ==========================
# 2) Helpers & Neighborhoods
# ==========================

def copy_plan(U: List[List[List[float]]]) -> List[List[List[float]]]:
    return [[row[:] for row in period] for period in U]


def tabu_neighbor(U: List[List[List[float]]],
                  params: InstanceParams,
                  key=None,
                  delta_choices=(5.0, 10.0, 20.0)):
    """
    Build a neighbor and return (newU, move_key).
    move_key = (t,i,j) used for tabu list.
    """
    T = params.T
    n_products = params.n_products
    n_fdcs = params.n_fdcs

    newU = copy_plan(U)
    if key is None:
        t = random.randrange(T)
        i = random.randrange(n_products)
        j = random.randrange(n_fdcs)
    else:
        t, i, j = key

    delta = random.choice(delta_choices)
    if random.random() < 0.5:
        newU[t][i][j] += delta
    else:
        newU[t][i][j] = max(0.0, newU[t][i][j] - delta)

    move_key = (t, i, j)
    return newU, move_key


# =================
# 3) Tabu Search
# =================

def tabu_search(params: InstanceParams,
                U_init: List[List[List[float]]],
                tabu_tenure: int = 5,
                n_iters: int = 200,
                neighborhood_size: int = 30) -> (float, List[List[List[float]]]):
    """
    Basic Tabu Search over plans U.
    Uses random sampled neighborhood and a tabu list on (t,i,j).
    Returns (best_cost, best_U).
    """
    current_U = copy_plan(U_init)
    current_cost = simulate_plan(params, current_U).total_cost
    best_U = copy_plan(current_U)
    best_cost = current_cost

    tabu_list = {}  # key: (t,i,j) -> remaining tenure

    for it in range(n_iters):
        candidates = []

        for _ in range(neighborhood_size):
            newU, move_key = tabu_neighbor(current_U, params)
            cost = simulate_plan(params, newU).total_cost
            candidates.append((cost, newU, move_key))

        # Update tabu tenures
        to_delete = []
        for key in tabu_list:
            tabu_list[key] -= 1
            if tabu_list[key] <= 0:
                to_delete.append(key)
        for key in to_delete:
            del tabu_list[key]

        candidates.sort(key=lambda x: x[0])

        chosen_cost, chosen_U, chosen_key = None, None, None
        for cost, U_cand, key in candidates:
            if key in tabu_list and cost >= best_cost:
                # tabu and does not improve global best: skip
                continue
            chosen_cost, chosen_U, chosen_key = cost, U_cand, key
            break

        if chosen_U is None:
            chosen_cost, chosen_U, chosen_key = candidates[0]

        current_U = chosen_U
        current_cost = chosen_cost

        if current_cost < best_cost:
            best_cost = current_cost
            best_U = copy_plan(current_U)

        tabu_list[chosen_key] = tabu_tenure

    return best_cost, best_U


# =====================
# 4) Tabu Tuning Loop
# =====================

def tune_tabu():
    params, U0 = build_synthetic_instance(
        n_products=200,
        n_fdcs=50,
        T=10,
        seed=123
    )

    print(f"Instance: {params.n_products} products, "
          f"{params.n_fdcs} FDCs, {params.T} periods")

    # Richer grid: more tabu tenures and neighborhood sizes
    tabu_tenures = [3, 5, 8, 12]
    neighborhood_sizes = [20, 40, 80]

    ts_configs = []
    for tenure in tabu_tenures:
        for nh in neighborhood_sizes:
            ts_configs.append({"tenure": tenure, "nh_size": nh})

    n_ts_runs = 5
    ts_iters = 200

    best_ts_cfg = None
    best_ts_avg = float("inf")

    print("\n=== Tabu Search tuning ===")
    for cfg in ts_configs:
        costs = []
        start_time = time.time()
        for run in range(n_ts_runs):
            random.seed(2000 + run)
            best_cost, _ = tabu_search(
                params, U0,
                tabu_tenure=cfg["tenure"],
                n_iters=ts_iters,
                neighborhood_size=cfg["nh_size"]
            )
            costs.append(best_cost)
        elapsed = time.time() - start_time
        avg_cost = sum(costs) / len(costs)
        print(f"TS cfg {cfg} -> avg best cost over {n_ts_runs} runs: {avg_cost:.2f} "
              f"(time {elapsed:.1f}s)")
        if avg_cost < best_ts_avg:
            best_ts_avg = avg_cost
            best_ts_cfg = cfg

    print(f"\nBest TS config: {best_ts_cfg} with avg best cost {best_ts_avg:.2f}")


if __name__ == "__main__":
    tune_tabu()